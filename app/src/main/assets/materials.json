[
  {
    "id": "mat_android_intro",
    "topicId": "android_intro",
    "title": "История и особенности Android",
    "content": "Android — это самая популярная в мире операционная система для мобильных устройств, созданная на базе ядра Linux. Проект стартовал в 2003 году и был приобретён Google в 2005. Первая коммерческая версия Android 1.0 появилась в 2008 году на смартфоне HTC Dream. С тех пор платформа прошла огромный путь: регулярно выходят новые версии с улучшениями безопасности, интерфейса и производительности. Ключевая особенность Android — его открытость и возможность встраивания на широкий спектр устройств: смартфоны, планшеты, телевизоры, умные часы, автомобильные системы и даже бытовую технику. Благодаря большому сообществу разработчиков и поддержке множества языков программирования (Java, Kotlin, C++), Android предоставляет гибкие инструменты для создания современных приложений. Интеграция с сервисами Google, модульность системы, постоянное развитие и поддержка множества производителей сделали Android лидером рынка, охватывающим более 70% всех мобильных устройств по миру. Важной особенностью является обширная экосистема — Google Play, сторонние магазины приложений, кастомные прошивки и поддержка большого количества девайсов от бюджетных до премиальных."
  },
  {
    "id": "mat_android_studio",
    "topicId": "android_studio",
    "title": "Установка и настройка Android Studio",
    "content": "Android Studio — это официальная среда разработки для Android, основанная на IntelliJ IDEA и предоставляющая все инструменты, необходимые для полного цикла разработки мобильных приложений. Чтобы начать, скачайте установщик с официального сайта developer.android.com/studio. При установке выберите компоненты: Android SDK, эмулятор (AVD Manager), плагины для Kotlin и Google Play Services. После установки запустите Android Studio, настройте пути к SDK и проверьте обновления. Рекомендуется загрузить дополнительные SDK Platforms и Tools через SDK Manager для поддержки разных версий Android. Первый проект создается через File → New Project: выберите шаблон (например, Empty Activity), задайте имя, минимальную версию SDK и язык (Kotlin или Java). Android Studio автоматически сгенерирует структуру проекта, настроит Gradle и предоставит стартовую разметку. Для отладки вы можете использовать эмулятор Android или подключить реальное устройство через USB. Встроенные средства профилирования и логирования позволяют анализировать производительность и находить ошибки на ранних этапах разработки."
  },
  {
    "id": "mat_project_structure",
    "topicId": "project_structure",
    "title": "Основные папки и файлы проекта",
    "content": "Структура Android-проекта организована таким образом, чтобы обеспечить простое масштабирование, поддержку и разделение логики. В корне находятся папки app (основной модуль приложения), gradle (скрипты сборки), build (автоматически сгенерированные файлы, не добавляются в систему контроля версий). Внутри app/src/main располагаются: AndroidManifest.xml (описание компонентов приложения и разрешений), папки java/ и kotlin/ (исходный код, обычно разделяется по пакетам), res/ (ресурсы: layout — разметка экранов, drawable — изображения и иконки, values — строки, стили, цвета). Кроме того, gradle-сценарии (build.gradle, settings.gradle) управляют зависимостями и процессом сборки, а также позволяют интегрировать внешние библиотеки. Поддерживаются также дополнительные модули (например, для тестов или библиотек), что важно для крупных проектов. Такая структура обеспечивает удобное разделение кода, ресурсов и конфигурации, облегчая поддержку и развитие приложения."
  },
  {
    "id": "mat_activity_lifecycle",
    "topicId": "activity_lifecycle",
    "title": "Жизненный цикл Activity",
    "content": "Activity — основной компонент пользовательского интерфейса в Android. Каждый экран приложения, как правило, реализуется в виде отдельной Activity. Жизненный цикл Activity описывает последовательность её состояний: onCreate (инициализация интерфейса, настройка данных), onStart (экран становится видимым), onResume (Activity получает фокус и готова к взаимодействию), onPause (Activity теряет фокус, часто используется для сохранения временных данных), onStop (экран скрывается, освобождаются ресурсы), onDestroy (Activity удаляется из памяти, происходит финальная очистка). Понимание жизненного цикла позволяет эффективно управлять ресурсами, обрабатывать неожиданные ситуации (например, поворот экрана или выход пользователя) и предотвращать утечки памяти. Для сохранения состояния (например, данных ввода) используется механизм onSaveInstanceState и восстановление в onRestoreInstanceState. Правильное управление жизненным циклом обеспечивает стабильную и отзывчивую работу приложения даже при сложных сценариях использования."
  },
  {
    "id": "mat_ui_basics",
    "topicId": "ui_basics",
    "title": "Базовые элементы интерфейса",
    "content": "В Android существует широкий спектр пользовательских элементов управления: TextView для вывода текста, Button для взаимодействия, EditText для ввода данных, ImageView для отображения изображений. Каждый элемент описывается в XML-разметке (или создается программно через Compose), может иметь стили, размеры, отступы, обработчики событий (например, onClick). Элементы объединяются в иерархические контейнеры — LinearLayout, RelativeLayout, ConstraintLayout, FrameLayout и современные компоненты Compose — Row, Column, Box. Современный подход с Jetpack Compose позволяет создавать интерфейс декларативно, используя функции-компоненты. Любой UI-элемент настраивается через свойства: цвет, шрифт, скругления, поведение при нажатии и др. Грамотное использование базовых элементов — фундамент удобного, адаптивного и визуально привлекательного интерфейса приложения."
  },
  {
    "id": "mat_kotlin_syntax",
    "topicId": "kotlin_syntax",
    "title": "Основы синтаксиса Kotlin",
    "content": "Kotlin — современный, статически типизированный язык, созданный для повышения эффективности и безопасности разработки. Переменные объявляются с помощью val (константа) или var (изменяемая): val age = 18, var score = 0. Основные типы: Int, Double, Boolean, String, List, Map. Функции определяются через ключевое слово fun: fun greet(name: String): String { return \"Hello, $name!\" }. Управляющие конструкции включают if-else, when (удобная замена switch), циклы for, while, do-while. Особенности Kotlin: интерполяция строк, расширяемые функции, null-safety (безопасность работы с null), коллекции с мощными методами (filter, map, reduce). Kotlin поддерживает лямбда-выражения, data-классы, объекты-одиночки (object), sealed-классы для ограничения наследования. Простой и лаконичный синтаксис уменьшает количество кода и повышает читаемость, а строгая типизация и продвинутая система контроля null-значений существенно сокращают количество ошибок в рантайме."
  },
  {
    "id": "mat_kotlin_functions",
    "topicId": "kotlin_functions",
    "title": "Функции и параметры в Kotlin",
    "content": "В Kotlin функции — это first-class citizens, то есть они могут быть объявлены внутри других функций, передаваться как параметры, возвращаться как значения. Синтаксис объявления: fun sum(a: Int, b: Int): Int { return a + b }. Поддерживаются значения по умолчанию: fun greet(name: String = \"Guest\"). Параметры можно помечать именованно при вызове функции, что повышает читаемость кода. Широко используются лямбда-выражения: val upper = { str: String -> str.uppercase() }. Для упрощения синтаксиса применяется сокращенная запись single-expression functions: fun square(x: Int) = x * x. Встроены inline-функции (например, forEach, map), которые оптимизируют выполнение и позволяют реализовывать собственные DSL (domain-specific languages). Возможна работа с vararg-параметрами, передача функции как ссылки (::functionName) и создание анонимных функций. Такой подход обеспечивает гибкость и мощные абстракции при проектировании кода."
  },
  {
    "id": "mat_kotlin_classes",
    "topicId": "kotlin_classes",
    "title": "Классы и объекты",
    "content": "В Kotlin классы — это основной инструмент структурирования и повторного использования кода. Класс объявляется через ключевое слово class: class User(val name: String). Можно добавлять методы, свойства, использовать конструкторы по умолчанию и дополнительные. Специальный модификатор data используется для data-классов — компактных контейнеров для хранения данных с автогенерацией equals, hashCode и toString. Поддерживаются интерфейсы (interface), абстрактные классы, наследование (open, override), а также объекты-одиночки (object), companion object для статических членов и sealed class для ограничения набора наследников. В Kotlin реализованы свойства с геттерами и сеттерами, делегирование (by), а также паттерн delegation для реализации интерфейсов без дублирования кода. Такой богатый функционал делает проектирование архитектуры гибким и выразительным."
  },
  {
    "id": "mat_kotlin_collections",
    "topicId": "kotlin_collections",
    "title": "Коллекции в Kotlin",
    "content": "Kotlin обладает мощной стандартной библиотекой коллекций: List (список), Set (множество), Map (отображение). Различают неизменяемые (listOf, setOf, mapOf) и изменяемые (mutableListOf, mutableSetOf, mutableMapOf) коллекции. Операции над коллекциями выполняются с помощью цепочек методов: map (трансформация элементов), filter (фильтрация), forEach (итерация), groupBy (группировка по ключу), sortedBy (сортировка). Например: val even = list.filter { it % 2 == 0 }. Для изменения структуры списка доступны методы add, remove, clear. Также реализованы функции для объединения коллекций (plus, minus), проверки на содержание (contains), поиска (find, firstOrNull) и преобразования в другие типы. Особое внимание уделяется работе с null-значениями и безопасной обработке пустых коллекций. Такой набор инструментов облегчает работу с большими массивами данных и позволяет строить сложную бизнес-логику с минимальным количеством кода."
  },
  {
    "id": "mat_kotlin_null_safety",
    "topicId": "kotlin_null_safety",
    "title": "Null safety и безопасность типов",
    "content": "Одно из главных преимуществ Kotlin — встроенная безопасность типов и нулей (null safety). В языке все переменные по умолчанию non-null: var text: String = \"Hello\"; попытка присвоить null вызовет ошибку на этапе компиляции. Для обозначения переменных, которым может быть присвоено null, используется знак ?: var text: String? = null. Для безопасного обращения применяются операторы ?. (безопасный вызов), ?: (оператор Элвиса для задания значения по умолчанию), !! (явное бросание исключения при null). Например, text?.length возвращает длину строки или null. Также доступны функции let, also, run, apply для обработки значений только если они не null. Такой подход предотвращает появление ошибок NullPointerException, делает код надежнее и упрощает отладку. Вся стандартная библиотека Kotlin написана с учетом null safety, что существенно снижает количество сбоев в приложениях."
  },
  {
    "id": "mat_compose_intro",
    "topicId": "compose_intro",
    "title": "Введение в Jetpack Compose",
    "content": "Jetpack Compose — это современный декларативный фреймворк для построения пользовательских интерфейсов на Android. Его главное отличие от старого подхода (XML-разметка + View) — создание UI через функции-компоненты на языке Kotlin. Каждый элемент интерфейса описывается как функция с состоянием и параметрами. Благодаря этому Compose позволяет создавать сложные и динамические интерфейсы с минимальным количеством кода, легко интегрируя бизнес-логику и обработку событий. Система автоматической перерисовки компонентов при изменении состояния (state management) упрощает работу с данными и анимациями. Compose поддерживает всю современную экосистему Android: Material Design, темизацию, работу с жестами и переходами, интеграцию с ViewModel и Navigation. Этот подход уменьшает количество шаблонного кода, ускоряет разработку и позволяет писать UI логично, прозрачно и удобно для поддержки."
  },
  {
    "id": "mat_compose_basic_elements",
    "topicId": "compose_basic_elements",
    "title": "Базовые компоненты Compose",
    "content": "В Jetpack Compose основной набор компонентов включает: Text (отображение текста), Button (кнопка), Image (изображение), Row (горизонтальное расположение), Column (вертикальное расположение), Box (слой для позиционирования). Каждый компонент — это функция, принимающая параметры и модификаторы (например, размер, отступы, цвет). Компоненты можно комбинировать для создания сложных экранов. В отличие от старых подходов, UI описывается только кодом на Kotlin, что ускоряет разработку и облегчает навигацию по проекту. Встроенные инструменты позволяют создавать свои кастомные компоненты и модификаторы, подключать анимации, использовать обработку жестов и динамическое изменение состояния. Jetpack Compose активно развивается, регулярно появляются новые компоненты и улучшения производительности, что делает его идеальным выбором для новых Android-проектов."
  },
  {
    "id": "mat_compose_state",
    "topicId": "compose_state",
    "title": "Состояние в Compose",
    "content": "Состояние — это основной механизм динамического изменения интерфейса в Jetpack Compose. Оно хранится с помощью функций remember и mutableStateOf: var counter by remember { mutableStateOf(0) }. Любое изменение состояния автоматически приводит к перерисовке зависимых компонентов. Для более сложных сценариев рекомендуется использовать ViewModel, в котором состояние хранится между пересозданиями экрана (например, при смене ориентации). Compose поддерживает односторонний поток данных: состояние идет сверху вниз (parent → child), а события вверх (child → parent). Такой подход облегчает тестирование, отладку и поддержку. Помимо базовых состояний, Compose интегрируется с потоками данных (Flow, LiveData), позволяет реализовать архитектурные паттерны (например, MVI), поддерживает сохранение состояния при сворачивании приложения. Благодаря этому, интерфейс всегда синхронизирован с данными и корректно реагирует на любые изменения."
  },
  {
    "id": "mat_compose_navigation",
    "topicId": "compose_navigation",
    "title": "Навигация в Compose",
    "content": "Навигация в Jetpack Compose реализуется через библиотеку Navigation Compose, которая позволяет создавать удобные графы экранов и управлять переходами между ними. Основные компоненты: NavHost (определяет структуру навигации), NavController (управляет переходами и стэком экранов), NavBackStackEntry (отслеживает текущий экран). Для передачи данных между экранами используются аргументы, а для обработки возврата — callbacks или result-API. Navigation Compose поддерживает анимации переходов, deep links, вложенные графы и управление состоянием back stack. Такой подход позволяет реализовать сложные сценарии навигации (например, мультистартовые flow, онбординг, авторизация), не теряя контроля над состоянием приложения. Сильная интеграция с ViewModel и Compose облегчает обработку навигационных событий и реакцию UI на изменения в стэке."
  },
  {
    "id": "mat_mvi_intro",
    "topicId": "mvi_intro",
    "title": "Архитектура приложения",
    "content": "Архитектура Android-приложения определяет, насколько удобно его разрабатывать, поддерживать и расширять. Основные задачи архитектуры: разделение ответственности (UI, бизнес-логика, работа с данными), обеспечение тестируемости и масштабируемости. Хорошая архитектура (например, Clean Architecture, MVVM, MVI) минимизирует связность между слоями, облегчает внедрение новых функций и устранение багов. В Android-проектах рекомендуется использовать паттерны ViewModel для хранения состояния, репозитории для доступа к данным и односторонний поток данных для предсказуемости поведения UI. В современной разработке активно применяются Dependency Injection (например, Koin или Dagger), навигационные фреймворки, сервисы для хранения данных (Room, DataStore), современные библиотеки для работы с сетью и реактивные паттерны для управления состоянием. Всё это позволяет создавать устойчивые и легко расширяемые приложения."
  },
  {
    "id": "mat_mvi_pattern",
    "topicId": "mvi_pattern",
    "title": "Паттерн MVI",
    "content": "Model-View-Intent (MVI) — это архитектурный паттерн, обеспечивающий односторонний поток данных и максимальную предсказуемость поведения интерфейса. Суть MVI: любое действие пользователя или событие переводится в Intent, который обрабатывается и изменяет State. View (интерфейс) всегда отображает только текущее состояние State, не управляет логикой и не хранит данных. Это упрощает отладку (можно легко отслеживать изменения состояния), масштабирование (компоненты легко переиспользовать и тестировать), а также интеграцию с современными библиотеками для управления состоянием (например, MVIKotlin). В рамках MVI строго отделяются Intent (события), State (состояние), Reducer (логика изменения состояния) и Executor (бизнес-логика, побочные эффекты), что делает код более модульным и прозрачным."
  },
  {
    "id": "mat_mvi_in_mvikotlin",
    "topicId": "mvi_in_mvikotlin",
    "title": "Использование MVIKotlin",
    "content": "MVIKotlin — это мощная библиотека для реализации MVI-паттерна на Kotlin и поддержки мультиплатформенных приложений. Она предоставляет базовые компоненты: Store (централизованное хранилище состояния), Executor (обработка событий и побочных эффектов), Reducer (изменение состояния), Label (сигналы для навигации и других side effects). MVIKotlin интегрируется с корутинами, поддерживает time-travel дебаггинг, логирование и работу с Flow. Использование MVIKotlin позволяет вынести бизнес-логику из UI, уменьшить связность кода, реализовать предсказуемое поведение даже в сложных сценариях (например, асинхронная загрузка данных, навигация, сообщения пользователю). Такой подход ускоряет разработку, облегчает внедрение новых фич и снижает количество ошибок."
  },
  {
    "id": "mat_repository_pattern",
    "topicId": "repository_pattern",
    "title": "Паттерн Repository",
    "content": "Паттерн Repository — это прослойка между источниками данных (например, база данных Room, API, DataStore) и бизнес-логикой приложения. Основная задача — скрыть детали реализации доступа к данным и предоставить унифицированный интерфейс. Это позволяет менять или комбинировать источники данных (например, кэшировать ответы из сети в базе) без изменения остального кода приложения. Репозитории облегчают тестирование (можно подменить реальную реализацию мок-объектом), способствуют повторному использованию и поддержке приложения. В Android-проектах обычно создаётся отдельный класс для каждого домена данных (UserRepository, CourseRepository, TopicRepository и т.д.), в котором реализованы методы для чтения, записи и обновления информации."
  },
  {
    "id": "mat_room_intro",
    "topicId": "room_intro",
    "title": "Введение в Room",
    "content": "Room — это современная ORM-библиотека от Google, предназначенная для упрощения работы с базой данных SQLite на Android. Она обеспечивает compile-time проверки SQL-запросов, генерирует код для CRUD-операций, поддерживает миграции и работу с потоками данных (Flow, LiveData). Основные элементы Room: Entity (классы-сущности, представляющие таблицы), Dao (интерфейсы с аннотированными запросами @Query, @Insert, @Delete), RoomDatabase (базовый класс, обеспечивающий доступ ко всем Dao). Room автоматически синхронизирует данные между потоками, облегчает работу с транзакциями и миграциями схемы. Благодаря интеграции с Kotlin Coroutines и архитектурными компонентами Android, Room становится незаменимым инструментом для устойчивого и масштабируемого хранения данных в приложениях."
  },
  {
    "id": "mat_room_entities",
    "topicId": "room_entities",
    "title": "Создание сущностей Room",
    "content": "Сущности (Entity) в Room описывают структуру таблиц в базе данных через аннотацию @Entity. Каждый Entity-класс содержит поля, которые становятся столбцами таблицы, а одно из них помечается @PrimaryKey. Дополнительно можно задавать индексы, связи между таблицами (ForeignKey) и ограничения. Dao (Data Access Object) — интерфейс, в котором объявляются методы доступа к данным и аннотируются соответствующими запросами: @Query, @Insert, @Update, @Delete. RoomDatabase — абстрактный класс, который предоставляет доступ ко всем Dao приложения и управляет созданием самой базы. Такая архитектура облегчает работу с данными, повышает читаемость кода и упрощает сопровождение приложения. Использование Room позволяет создавать сложные схемы, поддерживать миграции и обеспечивать безопасность данных на устройстве пользователя."
  },
  {
    "id": "mat_datastore",
    "topicId": "datastore",
    "title": "Использование DataStore",
    "content": "DataStore — это современное решение для хранения небольших настроек и пользовательских данных на Android, пришедшее на смену устаревшему SharedPreferences. DataStore поддерживает два режима: Preferences DataStore (работа с ключ-значение) и Proto DataStore (работа с proto-схемами для строгой типизации). Всё взаимодействие происходит асинхронно через Kotlin Coroutines и Flow, что предотвращает блокировку основного потока и повышает отзывчивость интерфейса. DataStore гарантирует целостность данных, автоматически обрабатывает транзакции и поддерживает миграции. Для интеграции достаточно создать ключи (preferencesKey), реализовать методы чтения и записи через edit, подписаться на flow данных. Такой подход делает хранение пользовательских настроек, тем оформления, токенов авторизации и других данных безопасным, масштабируемым и современным."
  }
]
